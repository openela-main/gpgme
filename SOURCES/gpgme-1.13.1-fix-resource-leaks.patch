diff --git a/lang/cpp/src/context.cpp b/lang/cpp/src/context.cpp
index c0a1dc21..e991dbc8 100644
--- a/lang/cpp/src/context.cpp
+++ b/lang/cpp/src/context.cpp
@@ -223,6 +223,7 @@ Context *Context::createForProtocol(Protocol proto)
         }
         break;
     default:
+        gpgme_release(ctx);
         return nullptr;
     }
 
@@ -273,6 +274,7 @@ std::unique_ptr<Context> Context::createForEngine(Engine eng, Error *error)
         }
         break;
     default:
+        gpgme_release(ctx);
         if (error) {
             *error = Error::fromCode(GPG_ERR_INV_ARG);
         }
diff --git a/lang/cpp/src/data.cpp b/lang/cpp/src/data.cpp
index 7a93cbc2..d08a29db 100644
--- a/lang/cpp/src/data.cpp
+++ b/lang/cpp/src/data.cpp
@@ -249,6 +249,7 @@ std::vector<GpgME::Key> GpgME::Data::toKeys(Protocol proto) const
     }
 
     if (gpgme_op_keylist_from_data_start (ctx->impl()->ctx, d->data, 0)) {
+        delete ctx;
         return ret;
     }
 
diff --git a/lang/python/gpgme.i b/lang/python/gpgme.i
index 87371af8..64b88d54 100644
--- a/lang/python/gpgme.i
+++ b/lang/python/gpgme.i
@@ -53,7 +53,7 @@
     {
       encodedInput = PyUnicode_AsUTF8String($input);
       if (encodedInput == NULL)
-        return NULL;
+        SWIG_fail;
       $1 = PyBytes_AsString(encodedInput);
     }
   else if (PyBytes_Check($input))
@@ -62,22 +62,25 @@
     PyErr_Format(PyExc_TypeError,
                  "arg %d: expected str, bytes, or None, got %s",
 		 $argnum, $input->ob_type->tp_name);
-    return NULL;
+    SWIG_fail;
   }
 }
 %typemap(freearg) const char * {
   Py_XDECREF(encodedInput$argnum);
 }
 
+%typemap(arginit) const char *[] {
+  $1 = NULL;
+}
+
 /* Likewise for a list of strings.  */
-%typemap(in) const char *[] (void *vector = NULL,
-                             size_t size,
+%typemap(in) const char *[] (size_t size,
                              PyObject **pyVector = NULL) {
   /* Check if is a list */
   if (PyList_Check($input)) {
     size_t i, j;
     size = PyList_Size($input);
-    $1 = (char **) (vector = malloc((size+1) * sizeof(char *)));
+    $1 = (char **) malloc((size+1) * sizeof(char *));
     pyVector = calloc(sizeof *pyVector, size);
 
     for (i = 0; i < size; i++) {
@@ -86,12 +89,7 @@
         {
           pyVector[i] = PyUnicode_AsUTF8String(o);
           if (pyVector[i] == NULL)
-            {
-              free(vector);
-              for (j = 0; j < i; j++)
-                Py_XDECREF(pyVector[j]);
-              return NULL;
-            }
+            SWIG_fail;
           $1[i] = PyBytes_AsString(pyVector[i]);
         }
       else if (PyString_Check(o))
@@ -101,8 +99,7 @@
                      "arg %d: list must contain only str or bytes, got %s "
                      "at position %d",
                      $argnum, o->ob_type->tp_name, i);
-	free($1);
-	return NULL;
+	SWIG_fail;
       }
     }
     $1[i] = NULL;
@@ -110,14 +107,17 @@
     PyErr_Format(PyExc_TypeError,
                  "arg %d: expected a list of str or bytes, got %s",
                  $argnum, $input->ob_type->tp_name);
-    return NULL;
+    SWIG_fail;
   }
 }
 %typemap(freearg) const char *[] {
-  size_t i;
-  free(vector$argnum);
-  for (i = 0; i < size$argnum; i++)
-    Py_XDECREF(pyVector$argnum[i]);
+  if (pyVector$argnum) {
+    size_t i;
+    for (i = 0; i < size$argnum; i++)
+      Py_XDECREF(pyVector$argnum[i]);
+    free(pyVector$argnum);
+  }
+  if ($1) free($1);
 }
 
 /* Release returned buffers as necessary.  */
@@ -135,7 +135,7 @@
   if (!PySequence_Check($input)) {
     PyErr_Format(PyExc_ValueError, "arg %d: Expected a list of gpgme_key_t",
 		 $argnum);
-    return NULL;
+    SWIG_fail;
   }
   if((numb = PySequence_Length($input)) != 0) {
     $1 = (gpgme_key_t*)malloc((numb+1)*sizeof(gpgme_key_t));
@@ -152,8 +152,7 @@
                      "arg %d: list must contain only gpgme_key_ts, got %s "
                      "at position %d",
                      $argnum, pypointer->ob_type->tp_name, i);
-        free($1);
-	return NULL;
+	SWIG_fail;
       }
       Py_DECREF(pypointer);
     }
@@ -179,7 +178,7 @@
     pypointer = _gpg_obj2gpgme_data_t($input, $argnum, &wrapper,
                                        &bytesio, &view);
     if (pypointer == NULL)
-      return NULL;
+      SWIG_fail;
     have_view = !! view.obj;
 
     /* input = $input, 1 = $1, 1_descriptor = $1_descriptor */
@@ -189,7 +188,7 @@
     if ((SWIG_ConvertPtr(pypointer,(void **) &$1, $1_descriptor,
          SWIG_POINTER_EXCEPTION | $disown )) == -1) {
       Py_DECREF(pypointer);
-      return NULL;
+      SWIG_fail;
     }
     Py_DECREF(pypointer);
   }
@@ -346,6 +345,11 @@
     PyErr_SetString(PyExc_TypeError, "Numeric argument expected");
 }
 
+%typemap(arginit) (void *buffer, size_t size), (char *buf, size_t buflen) {
+  $1 = NULL;
+  $2 = 0;
+}
+
 /* Those are for gpgme_data_read() and gpgme_strerror_r().  */
 %typemap(in) (void *buffer, size_t size), (char *buf, size_t buflen) {
   {
@@ -359,12 +363,12 @@
     else
       {
         PyErr_SetString(PyExc_TypeError, "Numeric argument expected");
-        return NULL;
+        SWIG_fail;
       }
 
     if (tmp$argnum < 0) {
       PyErr_SetString(PyExc_ValueError, "Positive integer expected");
-      return NULL;
+      SWIG_fail;
     }
     $2 = (size_t) tmp$argnum;
     $1 = ($1_ltype) malloc($2+1);
@@ -373,11 +377,11 @@
 %typemap(argout) (void *buffer, size_t size), (char *buf, size_t buflen) {
   Py_XDECREF($result);   /* Blow away any previous result */
   if (result < 0) {      /* Check for I/O error */
-    free($1);
+    if ($1) free($1);
     return PyErr_SetFromErrno(PyExc_RuntimeError);
   }
   $result = PyBytes_FromStringAndSize($1,result);
-  free($1);
+  if ($1) free($1);
 }
 
 /* For gpgme_data_write, but should be universal.  */
@@ -390,11 +394,11 @@
     {
       encodedInput = PyUnicode_AsUTF8String($input);
       if (encodedInput == NULL)
-        return NULL;
+        SWIG_fail;
       if (PyBytes_AsStringAndSize(encodedInput, (char **) &$1, &ssize) == -1)
         {
           Py_DECREF(encodedInput);
-          return NULL;
+          SWIG_fail;
         }
     }
   else if (PyBytes_Check($input))
@@ -403,7 +407,7 @@
     PyErr_Format(PyExc_TypeError,
                  "arg %d: expected str, bytes, or None, got %s",
 		 $argnum, $input->ob_type->tp_name);
-    return NULL;
+    SWIG_fail;
   }
 
   if (! $1)
@@ -432,8 +436,17 @@
     size++;
   }
   $result = PyList_New(size);
+  if ($result == NULL)
+    SWIG_fail;
   for (i=0,curr=$1; i<size; i++,curr=curr->next) {
     PyObject *o = SWIG_NewPointerObj(SWIG_as_voidptr(curr), $1_descriptor, %newpointer_flags);
+    if (o == NULL) {
+      int j;
+      for (j = 0; j < i; j++)
+        Py_XDECREF(PyList_GetItem($result, j));
+      Py_DECREF($result);
+      SWIG_fail;
+    }
     PyList_SetItem($result, i, o);
   }
 }
@@ -446,6 +459,8 @@
   PyObject *fragile;
   fragile = SWIG_NewPointerObj(SWIG_as_voidptr($1), $1_descriptor,
                                %newpointer_flags);
+  if (fragile == NULL)
+    SWIG_fail;
   $result = _gpg_wrap_result(fragile, name);
   Py_DECREF(fragile);
 }
@@ -469,22 +484,28 @@ wrapresult(gpgme_vfs_mount_result_t, "VFSMountResult")
   }
   $result = PyList_New(size);
   if ($result == NULL)
-    return NULL;	/* raise */
+    SWIG_fail;	/* raise */
   for (i=0,curr=$1; i<size; i++,curr=curr->next) {
     PyObject *fragile, *o;
     fragile = SWIG_NewPointerObj(SWIG_as_voidptr(curr), $1_descriptor,
                                  %newpointer_flags);
     if (fragile == NULL)
       {
+        int j;
+        for (j = 0; j < i; j++)
+          Py_XDECREF(PyList_GetItem($result, j));
         Py_DECREF($result);
-        return NULL;	/* raise */
+        SWIG_fail;	/* raise */
       }
     o = _gpg_wrap_result(fragile, "EngineInfo");
     Py_DECREF(fragile);
     if (o == NULL)
       {
+        int j;
+        for (j = 0; j < i; j++)
+          Py_XDECREF(PyList_GetItem($result, j));
         Py_DECREF($result);
-        return NULL;	/* raise */
+        SWIG_fail;	/* raise */
       }
     PyList_SetItem($result, i, o);
   }
diff --git a/src/engine-gpg.c b/src/engine-gpg.c
index dc2d9455..a1e40fe2 100644
--- a/src/engine-gpg.c
+++ b/src/engine-gpg.c
@@ -1122,6 +1122,7 @@ build_argv (engine_gpg_t gpg, const char *pgmname)
                    to avoid and given that we reach this here only
                    after a malloc failure for a small object, it is
                    probably better not to do anything.  */
+		free_argv (argv);
 		return gpg_error (GPG_ERR_GENERAL);
 	      }
 	    /* If the data_type is FD, we have to do a dup2 here.  */
@@ -1239,6 +1240,9 @@ read_status (engine_gpg_t gpg)
       buffer = realloc (buffer, bufsize);
       if (!buffer)
 	return gpg_error_from_syserror ();
+      /* Update buffer and bufsize here to prevent memory leaks.  */
+      gpg->status.buffer = buffer;
+      gpg->status.bufsize = bufsize;
     }
 
   nread = _gpgme_io_read (gpg->status.fd[0],
@@ -1351,8 +1355,6 @@ read_status (engine_gpg_t gpg)
     }
 
   /* Update the gpg object.  */
-  gpg->status.bufsize = bufsize;
-  gpg->status.buffer = buffer;
   gpg->status.readpos = readpos;
   return 0;
 }
@@ -1392,6 +1394,9 @@ read_colon_line (engine_gpg_t gpg)
       buffer = realloc (buffer, bufsize);
       if (!buffer)
 	return gpg_error_from_syserror ();
+      /* Prevent memory leaks.  */
+      gpg->colon.bufsize = bufsize;
+      gpg->colon.buffer  = buffer;
     }
 
   nread = _gpgme_io_read (gpg->colon.fd[0], buffer+readpos, bufsize-readpos);
@@ -1471,8 +1476,6 @@ read_colon_line (engine_gpg_t gpg)
     }
 
   /* Update the gpg object.  */
-  gpg->colon.bufsize = bufsize;
-  gpg->colon.buffer  = buffer;
   gpg->colon.readpos = readpos;
   return 0;
 }
diff --git a/src/engine-gpgsm.c b/src/engine-gpgsm.c
index ae5d8ef1..1f603f19 100644
--- a/src/engine-gpgsm.c
+++ b/src/engine-gpgsm.c
@@ -1533,8 +1533,10 @@ gpgsm_export (void *engine, const char *pattern, gpgme_export_mode_t mode,
   gpgsm->output_cb.data = keydata;
   err = gpgsm_set_fd (gpgsm, OUTPUT_FD, use_armor ? "--armor"
 		      : map_data_enc (gpgsm->output_cb.data));
-  if (err)
+  if (err) {
+    free (cmd);
     return err;
+  }
   gpgsm_clear_fd (gpgsm, INPUT_FD);
   gpgsm_clear_fd (gpgsm, MESSAGE_FD);
   gpgsm->inline_data = NULL;
@@ -1634,8 +1636,10 @@ gpgsm_export_ext (void *engine, const char *pattern[], gpgme_export_mode_t mode,
   gpgsm->output_cb.data = keydata;
   err = gpgsm_set_fd (gpgsm, OUTPUT_FD, use_armor ? "--armor"
 		      : map_data_enc (gpgsm->output_cb.data));
-  if (err)
+  if (err) {
+    free (line);
     return err;
+  }
   gpgsm_clear_fd (gpgsm, INPUT_FD);
   gpgsm_clear_fd (gpgsm, MESSAGE_FD);
   gpgsm->inline_data = NULL;
diff --git a/src/engine.c b/src/engine.c
index 05979c15..7e2e3800 100644
--- a/src/engine.c
+++ b/src/engine.c
@@ -460,7 +460,8 @@ _gpgme_set_engine_info (gpgme_engine_info_t info, gpgme_protocol_t proto,
       if (!new_version)
         {
           free (new_file_name);
-          free (new_home_dir);
+          if (new_home_dir)
+            free (new_home_dir);
           return gpg_error_from_syserror ();
         }
     }
diff --git a/src/gpgme-tool.c b/src/gpgme-tool.c
index 7a0bfcb3..f4ddd83b 100644
--- a/src/gpgme-tool.c
+++ b/src/gpgme-tool.c
@@ -1189,6 +1189,7 @@ gt_get_key (gpgme_tool_t gt, const char *pattern, gpgme_key_t *r_key)
                  similar hack to sort out such duplicates but it can't
                  do that while listing keys.  */
               gpgme_key_unref (key);
+              key = NULL;
               goto try_next_key;
             }
 	  if (!err)
diff --git a/src/keylist.c b/src/keylist.c
index cdb115fd..b7cbf3c3 100644
--- a/src/keylist.c
+++ b/src/keylist.c
@@ -1321,6 +1321,7 @@ gpgme_get_key (gpgme_ctx_t ctx, const char *fpr, gpgme_key_t *r_key,
                  similar hack to sort out such duplicates but it can't
                  do that while listing keys.  */
               gpgme_key_unref (key);
+              key = NULL;
               goto try_next_key;
             }
 	  if (!err)
